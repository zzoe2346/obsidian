<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 8 at column 268: Input is not proper UTF-8, indicate encoding !
Bytes: 0x08 0x63 0x6F 0x6D
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[til]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>til</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 06 Aug 2024 14:01:13 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 06 Aug 2024 14:01:12 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[헷갈리는 네트워크 용어 정리]]></title><description><![CDATA[ 
 <br><br>
<br>L4, Transport Layer, Segment, TCP, 호스트에 내장된 컴퓨터에서 사용됨(TCP/IP 스택, 네트워크 라이브러리 등)
<br>L3, Internet Layer, Packet, IP, 라우터장비 사용됨
<br>라우터는 네트워크 간에 데이터를 전달하고 경로를 결정하는 역할
<br>라우터는 패킷을 다른 네트워크로 라우팅하거나 동일한 네트워크 내에서 전달 
<br>라우터는 주로 네트워크 인터페이스와 라우팅 테이블을 갖춘 하드웨어 장비로 구현됨
]]></description><link>&lt;3&gt;유용한것들/네트워크-용어정리.html</link><guid isPermaLink="false">&lt;3&gt;유용한것들/네트워크-용어정리.md</guid><pubDate>Wed, 22 May 2024 06:54:14 GMT</pubDate></item><item><title><![CDATA[Docker교과서에서 익힌 명령어]]></title><description/></item><item><title><![CDATA[(24.06.30)MethodArgumentNotValidException 처리]]></title><description><![CDATA[ 
 <br><br><br>스프링과 타임리프로 SSR를 이용한 상품 관리용 관리자 페이지를 만드는데 클라이언트에서 잘못된 POST HTTP를 날리면 MethodArgumentNotValidException 이 발생함. 그런데 이걸 catch하려고 Controller Class의 이를 처리하는 Method에 아무리 try-catch를해도 예외가 안잡혔다. <br><br>MethodArgumentNotValidException 는 Spring MVC에서 Controller에 전달되기전 VIEW,MODEL 에서 예외가 발생해서 컨트롤러 안에서는 catch가 불가했던것임. <br><br>@ControllerAdvice는 전역 예외 처리가 가능 + 컨트롤러 예외처리 가능!<br>
@ExceptionHandler(MethodArgumentNotValidException.class)로 MethodArgumentNotValidException을 catch해서 "version-SSR/product-error" 페이지로 리턴해줌<br><br>
<br>@ControllerAdvice 로 전역 예외 처리가 가능한 사실을 처음 알게됨. 
<br>Spring MVC에 관해 더 알아야겠다는 생각! Controller 외부에서 예외가 발생할것이라는 생각은 전혀 하지 못했다.
<br><br>MethodArgumentNotValidException는 Spring MVC에서 요청이 컨트롤러 메서드에 도달하기 전에 데이터 바인딩 및 유효성 검사 과정에서 발생합니다. 이 예외는 주로 다음 위치에서 발생합니다:<br>
<br>
요청 데이터 바인딩 단계: Spring MVC는 요청 데이터를 컨트롤러 메서드의 파라미터로 바인딩합니다. 이 과정에서 @Valid 어노테이션이 적용된 객체에 대해 유효성 검사를 수행합니다. 만약 유효성 검사에 실패하면 MethodArgumentNotValidException 예외가 발생합니다.

<br>
HandlerMethodArgumentResolver: Spring MVC는 HandlerMethodArgumentResolver를 사용하여 컨트롤러 메서드의 파라미터를 해결합니다. 이 과정에서 유효성 검사 어노테이션이 있는 경우, MethodArgumentNotValidException이 발생할 수 있습니다.

<br>예를 들어, 컨트롤러 메서드가 다음과 같을 때:<br>@PostMapping("/products")
public ResponseEntity&lt;Product&gt; createProduct(@Valid @RequestBody Product product) {
    // Product 객체가 유효한 경우 비즈니스 로직 수행
    return ResponseEntity.ok(product);
}
복사<br>여기서 @Valid 어노테이션이 Product 객체에 적용되어 있습니다. Product 객체의 필드에 대해 유효성 검사가 실패하면, Spring은 컨트롤러 메서드에 도달하기 전에 MethodArgumentNotValidException을 발생시킵니다.<br><br>
<br>클라이언트 요청: 클라이언트가 /products 엔드포인트에 POST 요청을 보냅니다.
<br>디스패처 서블릿: 요청을 받아 적절한 핸들러(컨트롤러 메서드)를 찾습니다.
<br>HandlerMapping: 요청 URL과 컨트롤러 메서드를 매핑합니다.
<br>HandlerAdapter: 컨트롤러 메서드를 호출하기 위해 필요한 파라미터를 준비합니다. 이 단계에서 @Valid 어노테이션이 적용된 파라미터에 대해 유효성 검사를 수행합니다.
<br>유효성 검사: Product 객체의 유효성 검사가 수행되고, 유효하지 않은 경우 MethodArgumentNotValidException이 발생합니다.
<br>예외 처리: 예외가 발생하면 @ControllerAdvice로 설정된 전역 예외 처리기가 이 예외를 처리합니다.
<br><br>전역 예외 처리기를 설정하여 MethodArgumentNotValidException을 처리하는 방법은 다음과 같습니다:<br>@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public String handleValidationExceptions(MethodArgumentNotValidException ex) {
        return "version-SSR/product-error";
    }
}
복사<br>이 예외 처리기는 MethodArgumentNotValidException이 발생했을 때 호출되며, HTTP 응답 상태 코드를 400 Bad Request로 설정하고 "version-SSR/product-error" 뷰를 반환합니다.<br><br>컨트롤러와 예외 처리기를 포함한 예제 코드를 다시 확인해 보겠습니다.<br><br>@RestController
public class ProductController {

    @PostMapping("/products")
    public ResponseEntity&lt;Product&gt; createProduct(@Valid @RequestBody Product product) {
        // Product 객체가 유효한 경우 비즈니스 로직 수행
        return ResponseEntity.ok(product);
    }
}
복사<br><br>@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public String handleValidationExceptions(MethodArgumentNotValidException ex) {
        return "version-SSR/product-error";
    }
}
복사<br><br>public class Product {

    @NotNull(message = "Product name cannot be null")
    private String name;

    @Min(value = 1, message = "Price should be greater than zero")
    private BigDecimal price;

    // Getters and setters
}
복사<br>위 코드에서 ProductController는 Product 객체를 요청 본문에서 받아 처리합니다. @Valid 어노테이션이 적용된 Product 객체는 유효성 검사를 거치게 됩니다. 만약 Product 객체가 유효하지 않다면, MethodArgumentNotValidException이 발생하며, 이 예외는 전역 예외 처리기에서 처리됩니다.]]></description><link>&lt;1&gt;겪은-문제와-해결과정/240630-스프링-methodargumentnotvalidexception.html</link><guid isPermaLink="false">&lt;1&gt;겪은-문제와-해결과정/240630-스프링-MethodArgumentNotValidException.md</guid><pubDate>Sun, 30 Jun 2024 06:35:15 GMT</pubDate></item><item><title><![CDATA[@Valid, @ControllerAdvice로 코드 리팩토링]]></title><description><![CDATA[ 
 <br><br>@Valid로 객체는 편하게 유효성 검사를함. ]]></description><link>&lt;1&gt;겪은-문제와-해결과정/240701-예외처리-리팩토링.html</link><guid isPermaLink="false">&lt;1&gt;겪은-문제와-해결과정/240701-예외처리-리팩토링.md</guid><pubDate>Mon, 01 Jul 2024 08:59:32 GMT</pubDate></item><item><title><![CDATA[스택활용시의 시간복잡도]]></title><description><![CDATA[ 
 <br><br><br>
<a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/17298" target="_blank">https://www.acmicpc.net/problem/17298</a>
<br>
<br>1&lt;=n &lt;=1,000,000 이라서 O(n^2)이면 초당 1조연산을 해야한다. 초당 1~2억 연산이 가능하다 하니 시간 제한이 1초인 이문제에서는 2중 for문을 하지말아야 한다.
<br>아래는 Stack을 활용했는데 O(n)의 시간복잡도를 자랑한다. 처음에는 for문에 while문이 있었기네 O(n^2)이 아닌가 해서 혼란이 심했다. 
<br>하지만 이렇게 생각하면된다 =&gt; 

<br>스택은 푸시한만큼 팝할수있다. 
<br>bStack에 푸시되는건 n개
<br>for문이 도는동안 스택은 push n번, pop n번 총 2n번만 while문을 돌리는것!!!!!!
<br>ex) n=100일때, 1루프:a번 push ... 100루트:0번 이런식인것!


<br>//bStack에 push n번이면 pop도 n번만 발생할 수 밖에 없다.  
//스택은 푸시,팝으로 시간복잡도 계산하면 될듯하네  
for (int i = 0; i &lt; N; i++) {  
    int value = aStack.pop();  
    while (true){  
        if(bStack.isEmpty()) {  
            answerStack.push(-1);  
            bStack.push(value);  
            break;  
        }  
        if(bStack.peek()&gt;value){  
            answerStack.push(bStack.peek());  
            bStack.push(value);  
            break;  
        }else {  
            bStack.pop();  
        }  
     }  
}

복사]]></description><link>&lt;1&gt;겪은-문제와-해결과정/스택활용시-시간복잡도.html</link><guid isPermaLink="false">&lt;1&gt;겪은-문제와-해결과정/스택활용시-시간복잡도.md</guid><pubDate>Thu, 13 Jun 2024 04:04:47 GMT</pubDate></item><item><title><![CDATA[코테에서 시간복잡도 고려해보기]]></title><description><![CDATA[ 
 <br><br>반성<br>
<br>시간복잡도에 관해 너무 생각을 안한다. 네이버 코테에서도 그냥 테스트케이스만 통과하기 급급했다. 평소 시간복잡도에 관해 고려하면서 코테 연습을 진행하자.
<br>이 문제의 힌트만 보고 따라 구현했는데 메모리도 초과, 시간도 초과한 듯 하다. (그런데 이 문제에서 시간제한, 메모리제한에 대한 글귀가 없다. 옛날거라서 그런가?)
<br>2중 for문에 각별히 주의해야한다.
<br>n이 가장 최고일때 10^7인데, 2중 for문을 하면, O(n^2)
<br><a rel="noopener" class="external-link" href="https://invrtd-h.tistory.com/50" target="_blank">https://invrtd-h.tistory.com/50</a> 이 블로그를 보면, n &lt;= 10,000,000일때 요구되는 시간복잡도는 O(n)이라고 되어있다.
<br>블로그에 1초에 2억(2*10^8)번 연산할 수 있다(1초에 1억도 있고 불분명한듯) 는 명제를 참으로 여기고 시간복잡도를 대해 보라는 조언이 있음. 그러면 O(n^2)은 10^14가 되니 1초에 2억을 초과한다.
<br>아래 Reference를 보면 n크기별 적절한 시간복잡도를 표로 정리해놓았다. 맹신은 X
<br><br>
<br><a data-tooltip-position="top" aria-label="https://velog.io/@doriskim/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84Big-O-%EC%A0%95%EB%A6%AC" rel="noopener" class="external-link" href="https://velog.io/@doriskim/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84Big-O-%EC%A0%95%EB%A6%AC" target="_blank">https://velog.io/@doriskim/시간복잡도Big-O-정리</a>
<br><a rel="noopener" class="external-link" href="https://invrtd-h.tistory.com/50" target="_blank">https://invrtd-h.tistory.com/50</a>
<br><a rel="noopener" class="external-link" href="https://cowimming.tistory.com/239" target="_blank">https://cowimming.tistory.com/239</a>
<br><a data-tooltip-position="top" aria-label="https://velog.io/@jiyaho/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8B%9C%EA%B0%84-%EC%A0%9C%ED%95%9C%EA%B3%BC-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84" rel="noopener" class="external-link" href="https://velog.io/@jiyaho/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8B%9C%EA%B0%84-%EC%A0%9C%ED%95%9C%EA%B3%BC-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84" target="_blank">https://velog.io/@jiyaho/알고리즘-시간-제한과-시간-복잡도</a>
]]></description><link>&lt;1&gt;겪은-문제와-해결과정/시간복잡도.html</link><guid isPermaLink="false">&lt;1&gt;겪은-문제와-해결과정/시간복잡도.md</guid><pubDate>Thu, 13 Jun 2024 04:03:56 GMT</pubDate></item><item><title><![CDATA[return o2 - o1;의 치명적 약점]]></title><description><![CDATA[ 
 <br><br>
<a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/7662" target="_blank">https://www.acmicpc.net/problem/7662</a>
<br><br>2개의 우선순위큐와 1개의 맵을 활용했다. 시작방향은 맞았지만, 중간에서 틀림. 맵을 활용해서 카운팅한다는 개념이 새로웠다.<br>
주어지는 값이 INTEGER_MAX, INTEGER_MIN 까지 주어진다. 이때<br>PriorityQueue&lt;Integer&gt; maxQ = new PriorityQueue&lt;&gt;((o1,o2)-&gt;{
	return o2-o1;
});
복사<br>이런 코드를 사용해서 내림차순큐를 구현했는데 만약에 o2 = INTEGER_MAX이고 o1이 INTEGER_MIN이면 오버플로가 발생해서 의도하지 않은 결과가 나오는것!!! 안전하게<br>PriorityQueue&lt;Integer&gt; maxQ = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());
복사<br>이렇게 작성하거나<br>PriorityQueue&lt;Integer&gt; maxQ = new PriorityQueue&lt;&gt;((o1,o2)-&gt;{
	if(o1&gt;o2){
	}else{
	}
});
복사<br>이렇게 꼭 if문으로 대소를 비교하자!!!]]></description><link>&lt;1&gt;겪은-문제와-해결과정/comparatorvso1o2.html</link><guid isPermaLink="false">&lt;1&gt;겪은-문제와-해결과정/comparatorVSo1o2.md</guid><pubDate>Wed, 22 May 2024 06:54:42 GMT</pubDate></item><item><title><![CDATA[Java의 equals(), hashCode(), Objects Class(Set 오버라이딩시 equals(),hashcode()를 둘다 해야야되는 이유)]]></title><description><![CDATA[ 
 <br><br>@Override public int hashCode() { 

	return Objects.hash(a,b,c); // name 필드의 해시코드를 반환한다. 

}
복사<br>
<br>Objects.hash() 는 hash코드 생성해줌. native활용
<br>hashMap, hashSet 등의 hash를 이용하는 자료구조는 hashcode() 일치여부-&gt;equal() 일치여부 순서로 같은 객체인지 확인한다. 
<br><br>
<br><a rel="noopener" class="external-link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html" target="_blank">https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html</a>
<br><a rel="noopener" class="external-link" href="https://youtu.be/Go-Yf09xxzQ?si=3jkHE1i_U1c0JerC" target="_blank">https://youtu.be/Go-Yf09xxzQ?si=3jkHE1i_U1c0JerC</a>
<br><a rel="noopener" class="external-link" href="https://inpa.tistory.com/entry/JAVA-%E2%98%95-equals-hashCode-%EB%A9%94%EC%84%9C%EB%93%9C-%EA%B0%9C%EB%85%90-%ED%99%9C%EC%9A%A9-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0" target="_blank">https://inpa.tistory.com/entry/JAVA-%E2%98%95-equals-hashCode-%EB%A9%94%EC%84%9C%EB%93%9C-%EA%B0%9C%EB%85%90-%ED%99%9C%EC%9A%A9-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0</a>
]]></description><link>&lt;1&gt;겪은-문제와-해결과정/equals-hashcode.html</link><guid isPermaLink="false">&lt;1&gt;겪은-문제와-해결과정/equals-hashcode.md</guid><pubDate>Wed, 22 May 2024 06:54:05 GMT</pubDate></item><item><title><![CDATA[Union-Find]]></title><description><![CDATA[ 
 <br><br>
<a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1717" target="_blank">https://www.acmicpc.net/problem/1717</a>
<br>
<a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1976" target="_blank">https://www.acmicpc.net/problem/1976</a>
<br><br>이 알고리즘을 몰라서 계속 시간초과와 메모리초과에 시달리다가 이 알고리즘으로 이 문제들로 부터 해방되었다.<br><br>static int getParent(int[] parents,int x){  
    if(parents[x]==x) return x;  
    else{  
	//이 부분이 잘 이해가 안되었었다. 
	//그냥 아래 2줄을 return getParent(parents,parents[x]);로 하면 시간초과가 발생한다.
	//getParent()메서드가 한번 훝은 부분을 또 훝는것이기 때문
	//어차피 루트노드만 같은지 판단하는게 핵심이기 때문에 parents[x] = getParent(parents,parents[x]) 이 코드로 갱신 시키는게 시간복잡도 측면에서 매우 유리하고 당연한것!!!
        parents[x] = getParent(parents,parents[x]);  
        return parents[x];  
    }  
}
static void union(int[] parents,int a, int b){  
    a = getParent(parents, a);  
    b = getParent(parents, b);  
    if(a == b) return;  
    if(a&lt;b){  
        parents[b] = a;  
    }else {  
        parents[a] = b;  
    }  
  
}  
static boolean find(int[] parents,int a, int b){  
    a = getParent(parents, a);  
    b = getParent(parents, b);  
    if(a == b) return true;  
    else return false;  
}
복사<br><br>
<br><a rel="noopener" class="external-link" href="https://ip99202.github.io/posts/%EC%9C%A0%EB%8B%88%EC%98%A8-%ED%8C%8C%EC%9D%B8%EB%93%9C(Union-Find)/" target="_blank">https://ip99202.github.io/posts/%EC%9C%A0%EB%8B%88%EC%98%A8-%ED%8C%8C%EC%9D%B8%EB%93%9C(Union-Find)/</a>
]]></description><link>&lt;1&gt;겪은-문제와-해결과정/union-find.html</link><guid isPermaLink="false">&lt;1&gt;겪은-문제와-해결과정/Union-Find.md</guid><pubDate>Wed, 22 May 2024 06:54:46 GMT</pubDate></item><item><title><![CDATA[1. 읽은 책들]]></title><description><![CDATA[ 
 <br><br><br><br>]]></description><link>&lt;2&gt;자료-모음/1-읽은-책들.html</link><guid isPermaLink="false">&lt;2&gt;자료-모음/1-읽은-책들.md</guid><pubDate>Sun, 30 Jun 2024 06:23:01 GMT</pubDate></item><item><title><![CDATA[2. 좋은 유튜브 채널 모음]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=iyl9bfp_8ag&amp;ab_channel=%EB%8F%99%EB%B9%88%EB%82%98" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=iyl9bfp_8ag&amp;ab_channel=%EB%8F%99%EB%B9%88%EB%82%98" target="_blank">힙정렬 설명 너무 굳</a>]]></description><link>&lt;2&gt;자료-모음/2-좋은-유튜브-채널-모음.html</link><guid isPermaLink="false">&lt;2&gt;자료-모음/2-좋은-유튜브-채널-모음.md</guid><pubDate>Sun, 30 Jun 2024 06:23:38 GMT</pubDate></item><item><title><![CDATA[3. 기업의 기술블로그 모음]]></title><description><![CDATA[ 
 <br>]]></description><link>&lt;2&gt;자료-모음/3-기업-기술블로그-모음.html</link><guid isPermaLink="false">&lt;2&gt;자료-모음/3-기업-기술블로그-모음.md</guid><pubDate>Sun, 30 Jun 2024 06:31:22 GMT</pubDate></item><item><title><![CDATA[4. 참조할 만한 블로그 모음]]></title><description><![CDATA[ 
 <br>]]></description><link>&lt;2&gt;자료-모음/4-참조할-만한-블로그-모음.html</link><guid isPermaLink="false">&lt;2&gt;자료-모음/4-참조할-만한-블로그-모음.md</guid><pubDate>Sun, 30 Jun 2024 06:33:16 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[ 
 ]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Tue, 06 Aug 2024 13:59:05 GMT</pubDate></item></channel></rss>